class Solution {
    public boolean isPalindrome(int x) {
        // 負數或最後一位是0但數字不是0 → 一定不是回文
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int rev = 0; // 儲存數字後半部分反轉
        while (x > rev) {
            rev = rev * 10 + x % 10; // 將 x 的最後一位加到 rev 後面
            x /= 10; // 移除 x 的最後一位
        }

        // 偶數長度: x == rev
        // 奇數長度: x == rev/10 (中間數字可忽略)
        return x == rev || x == rev / 10;
    }
}

/*
解題邏輯與思路：
1. 問題本質：
   - 判斷整數是否為回文（正著讀和倒著讀一樣）。

2. 解法設計（反轉後半部分）：
   - 避免將整個數字轉成字串，節省空間。
   - 只反轉數字的後半部分，直到 rev >= x：
       1. x > rev → 後半部分未反轉完
       2. x <= rev → 已反轉後半部分
   - 最後比較 x 與 rev：
       - 偶數長度 → x == rev
       - 奇數長度 → 中間位不影響 → x == rev/10

3. 範例：
   - x = 1221 → 反轉後半 21 → x=12, rev=12 → 相等 → 回文
   - x = 12321 → 反轉後半 12 → x=12, rev=123 → x == rev/10 → 回文

4. 為什麼可行：
   - 只需要反轉一半數字即可，避免溢位。
   - 時間複雜度 O(log10(x))，空間複雜度 O(1)。

時間複雜度：O(log10(x))  
空間複雜度：O(1)
*/
